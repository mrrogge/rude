local class = require('middleclass')
local Engine = require('rude.Engine')
local Scene = require('rude.Scene')
local Exception = require('rude.Exception')

describe('an Engine instance:', function()
    local e
    before_each(function()
        e = Engine()
    end)

    it('exposes DataContext class', function()
        assert.is.equal(e.DataContext, require('rude.DataContext'))
    end)
    it('exposes Engine class', function()
        assert.is.equal(e.Engine, require('rude.Engine'))
    end)
    it('exposes Exception class', function()
        assert.is.equal(e.Exception, require('rude.Exception'))
    end)
    it('exposes logging module', function()
        assert.is.equal(e.logging, require('rude.logging'))
    end)
    it('exposes MissingComClassException class', function()
        assert.is.equal(e.MissingComClassException, require('rude.MissingComClassException'))
    end)
    it('exposes MissingComException class', function()
        assert.is.equal(e.MissingComException, require('rude.MissingComException'))
    end)
    it('exposes PoolableMixin', function()
        assert.is.equal(e.PoolableMixin, require('rude.PoolableMixin'))
    end)
    it('exposes RudeObject class', function()
        assert.is.equal(e.RudeObject, require('rude.RudeObject'))
    end)
    it('exposes Scene class', function()
        assert.is.equal(e.Scene, require('rude.Scene'))
    end)
    it('exposes Sys class', function()
        assert.is.equal(e.Sys, require('rude.Sys'))
    end)
    it('exposes TablePool class', function()
        assert.is.equal(e.TablePool, require('rude.TablePool'))
    end)
    it('exposes util module', function()
        assert.is.equal(e.util, require('rude.util'))
    end)
    it('exposes bitserPlugin', function()
        assert.is.equal(e.plugins.bitserPlugin, require('rude.plugins.bitserPlugin'))
    end)
    it('exposes dkjsonPlugin', function()
        assert.is.equal(e.plugins.dkjsonPlugin, require('rude.plugins.dkjsonPlugin'))
    end)
    it('exposes lovePlugin', function()
        assert.is.equal(e.plugins.lovePlugin, require('rude.plugins.lovePlugin'))
    end)
    it('exposes stdPlugin', function()
        assert.is.equal(e.plugins.stdPlugin, require('rude.plugins.stdPlugin'))
    end)

    describe('initialize()', function()
        it('returns the instance', function()
            assert.is.equal(e:initialize(), e)
        end)
        it('applies stdPlugin', function()
            stub(e, 'usePlugin')
            e:initialize()
            assert.stub(e.usePlugin).was.called_with(match.is_ref(e), require('rude.plugins.stdPlugin'))
        end)
    end)

    describe('updateConfig()', function()
        it('does not error', function()
            assert.has_no.errors(function()
                e:updateConfig({})
            end)
        end)
    end)

    --Top-level event functions
    describe('load()', function()
        it('calls onLoad()', function()
            spy.on(e, 'onLoad')
            e:load()
            assert.spy(e.onLoad).was.called()
        end)
    end)

    describe('onLoad()', function()
        it('does not error', function()
            assert.has_no.errors(function()
                e:onLoad()
            end)
        end)
    end)

    describe('update()', function()
        it('calls update() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'update')
            e:update(0.1)
            assert.spy(scene.update).was.called()
        end)
        it('with single scene mode does not call update() on scene below the top', function()
            e:updateConfig({sceneMode='single'})
            local bottomScene = e:newScene('bottomScene')
            e:pushScene(bottomScene)
            spy.on(bottomScene, 'update')
            local topScene = e:newScene('topScene')
            e:pushScene(topScene)
            e:update(0.1)
            assert.spy(bottomScene.update).was_not.called()
        end)
        it('with multi scene mode calls update() on all scenes', function()
            e:updateConfig({sceneMode='multi'})
            local bottomScene = e:newScene('bottomScene')
            e:pushScene(bottomScene)
            spy.on(bottomScene, 'update')
            local topScene = e:newScene('topScene')
            e:pushScene(topScene)
            e:update(0.1)
            assert.spy(bottomScene.update).was.called()
        end)
        it("when engine is configured for dynamic steps it passes dt to the scene's update()", function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'update')
            local dt = 0.1
            e:update(dt)
            assert.spy(scene.update).was.called_with(match._, dt)
        end)
        describe('when engine is configured for fixed steps', function()
            it('and dt is less than the fixed step update() is not called for the scene', function()
                e:importConfig({updateStep=0.2})
                local scene = e:newScene('test')
                e:pushScene(scene)
                spy.on(scene, 'update')
                local dt = 0.1
                e:update(dt)
                assert.spy(scene.update).was_not.called()
            end)
            it('and dt is equal to the fixed step amount the scene update() is called with the fixed dt', function()
                local dt = 0.2
                e:importConfig({updateStep=dt})
                local scene = e:newScene('test')
                e:pushScene(scene)
                spy.on(scene, 'update')
                e:update(dt)
                assert.spy(scene.update).was.called_with(match._, dt)
            end)
            it('and dt is greater than the fixed step amount the scene update() is called with the fixed dt', function()
                e:importConfig({updateStep=0.2})
                local scene = e:newScene('test')
                e:pushScene(scene)
                spy.on(scene, 'update')
                e:update(0.3)
                assert.spy(scene.update).was.called_with(match._, 0.2)
            end)
            it('and dt is greater than twice the fixed step amount, the scene update() is called multiple times', function()
                e:importConfig({updateStep=0.2})
                local scene = e:newScene('test')
                e:pushScene(scene)
                spy.on(scene, 'update')
                e:update(0.5)
                assert.spy(scene.update).was.called(2)
            end)
        end)
    end)

    describe('draw()', function()
        it('calls draw() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'draw')
            e:draw()
            assert.spy(scene.draw).was.called()
        end)
        it('with single scene mode does not call draw() on scenes below the top', function()
            e:updateConfig({sceneMode='single'})
            local bottomScene = e:newScene('bottomScene')
            e:pushScene(bottomScene)
            spy.on(bottomScene, 'draw')
            local topScene = e:newScene('topScene')
            e:pushScene(topScene)
            e:draw()
            assert.spy(bottomScene.draw).was_not.called()
        end)
        it('with multi scene mode calls draw() on scenes below the top', function()
            e:updateConfig({sceneMode='multi'})
            local bottomScene = e:newScene('bottomScene')
            e:pushScene(bottomScene)
            spy.on(bottomScene, 'draw')
            local topScene = e:newScene('topScene')
            e:pushScene(topScene)
            e:draw()
            assert.spy(bottomScene.draw).was.called()
        end)
    end)

    describe('keyPressed()', function()
        it('calls keypressed() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'keypressed')
            e:keyPressed('', '', false)
            assert.spy(scene.keypressed).was.called()
        end)
    end)

    describe('keyReleased()', function()
        it('calls keyreleased() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'keyreleased')
            e:keyReleased('', '')
            assert.spy(scene.keyreleased).was.called()
        end)
    end)

    describe('mouseMoved()', function()
        it('calls mousemoved() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'mousemoved')
            e:mouseMoved(0,0,0,0,false)
            assert.spy(scene.mousemoved).was.called()
        end)
    end)

    describe('mousePressed()', function()
        it('calls mousepressed() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'mousepressed')
            e:mousePressed(0,0,0,false,1)
            assert.spy(scene.mousepressed).was.called()
        end)
    end)

    describe('mouseReleased()', function()
        it('calls mousereleased() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'mousereleased')
            e:mouseReleased(0,0,0,false,1)
            assert.spy(scene.mousereleased).was.called()
        end)
    end)

    describe('wheelMoved()', function()
        it('calls wheelmoved() on the top scene', function()
            local scene = e:newScene('test')
            e:pushScene(scene)
            spy.on(scene, 'wheelmoved')
            e:wheelMoved(0,0)
            assert.spy(scene.wheelmoved).was.called()
        end)
    end)

    --scene functions
    describe('registerScene()', function()
        it('registers the scene to an ID', function()
            local scene = Scene(e)
            e:registerScene('test', scene)
            assert.is.equal(scene, e:getScene('test'))
        end)
        it('returns the engine', function()
            assert.is.equal(e, e:registerScene('test', Scene(e)))
        end)
    end)

    describe('unregisterScene()', function()
        it('unregisters an existing registered scene', function()
            local scene = Scene(e)
            e:registerScene('test', scene)
            e:unregisterScene('test')
            assert.is.Nil(e:getScene('test'))
        end)
        it('returns the engine', function()
            assert.is.equal(e, e:unregisterScene('test'))
        end)
    end)

    describe('getScene()', function()
        it('returns the registered scene', function()
            local scene = Scene(e)
            e:registerScene('test', scene)
            assert.is.equal(scene, e:getScene('test'))
        end)
        it('when no scene exists return nil and an exception', function()
            local scene, err = e:getScene('test')
            assert.is.Nil(scene)
            assert.is.truthy(err:isInstanceOf(Exception))
        end)
    end)

    describe('sceneExists()', function()
        it('returns true if the scene is registered', function()
            local scene = Scene(e)
            e:registerScene('test', scene)
            assert.is.True(e:sceneExists('test'))
        end)
        it('returns false if the scene is not registered', function()
            assert.is.False(e:sceneExists('test'))
        end)
    end)

    describe('newScene()', function()
        it('when passed a class, returns a new instance of that class', function()
            local TestScene = Scene:subclass('TestScene')
            local scene = e:newScene('test', TestScene)
            assert.is.instanceOf(scene, TestScene)
        end)
        it('initializes the new scene with the engine reference', function()
            spy.on(Scene, 'initialize')
            e:newScene('test')
            assert.spy(Scene.initialize).was.called_with(match._, match.is_ref(e), match._)
            Scene.initialize:revert()
        end)
        it('initializes the new scene with the config table', function()
            spy.on(Scene, 'initialize')
            local config = {}
            e:newScene('test', Scene, {})
            assert.spy(Scene.initialize).was.called_with(match._, match._, config)
        end)
        it('when not passed a class, defaults to rude.Scene', function()
            local scene = e:newScene('test')
            assert.is.instanceOf(scene, Scene)
        end)
        it('registers the new scene to the engine with the passed id', function()
            local sceneId = 'test'
            local scene = e:newScene(sceneId)
            assert.is.equal(scene, e:getScene(sceneId))
        end)
        it('pushes new scene to the top of the stack', function()
            local scene = e:newScene('test')
            assert.is.equal(scene, e:getTopScene())
        end)
    end)

    describe('getSceneStackSize()', function()
        it('returns 0 if no scenes are on the stack', function()
            assert.is.equal(0, e:getSceneStackSize())
        end)
        it('returns 1 if one scene is on the stack', function()
            e:pushScene(Scene(e))
            assert.is.equal(1, e:getSceneStackSize())
        end)
        it('returns number of scenes added to the stack', function()
            e:pushScene(Scene(e))
            e:pushScene(Scene(e))
            assert.is.equal(2, e:getSceneStackSize())
        end)
    end)

    describe('sceneExistsAtIndex()', function()
        it('returns true if a scene exists at the specified index', function()
            e:pushScene(Scene(e))
            assert.is.True(e:sceneExistsAtIndex(1))
        end)
        it('returns false if the scene does not exist', function()
            assert.is.False(e:sceneExistsAtIndex(1))
        end)
    end)

    describe('getTopScene()', function()
        it('returns the top scene', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:getTopScene())
        end)
    end)

    describe('getSceneFromTop()', function()
        it('when passed nothing returns the top scene', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:getSceneFromTop())
        end)
        it('returns the scene at the offset from the top of the stack', function()
            local scene = Scene(e)
            e:pushScene(scene)
            e:pushScene(Scene(e))
            assert.is.equal(scene, e:getSceneFromTop(1))
        end)
    end)

    describe('getSceneAtIndex()', function()
        it('returns the scene at the stack index number (bottom to top)', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:getSceneAtIndex(1))
        end)
    end)

    describe('pushScene()', function()
        it('returns the engine', function()
            assert.is.equal(e, e:pushScene(Scene(e)))
        end)
        it('when passed a scene instance adds it to the stack', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:getTopScene())
        end)
        it('when passed a scene id adds that scene to the stack', function()
            local scene = e:newScene('test')
            e:pushScene('test')
            assert.is.equal(scene, e:getTopScene())
        end)
        it('adds scene on top of existing scenes in the stack', function()
            e:pushScene(Scene(e))
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:getTopScene())
        end)
    end)

    describe('popScene()', function()
        it('returns the top scene', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:popScene())
        end)
    end)

    describe('isSceneRegistered()', function()
        it('returns scene id if scene is registered', function()
            local scene = Scene(e)
            e:registerScene('test', scene)
            assert.is.equal('test', e:isSceneRegistered(scene))
        end)
        it('returns nothing if scene is not registered', function()
            assert.is.Nil(e:isSceneRegistered(Scene(e)))
        end)
    end)

    describe('swapScene()', function()
        it('adds scene to top of stack', function()
            e:pushScene(Scene(e))
            local scene = Scene(e)
            e:swapScene(scene)
            assert.is.equal(scene, e:getTopScene())
        end)
        it('adds scene registered to id to the top of stack', function()
            e:pushScene(Scene(e))
            local scene = e:newScene('test')
            e:swapScene('test')
            assert.is.equal(scene, e:getTopScene())
        end)
        it('returns the top scene', function()
            local scene = Scene(e)
            e:pushScene(scene)
            assert.is.equal(scene, e:swapScene(Scene(e)))
        end)
    end)

    describe('usePlugin()', function()
        it('applies plugin to the engine', function()
            local plugin = function(engine)
                engine.test = 'test'
            end
            e:usePlugin(plugin)
            assert.is.equal(e.test, 'test')
        end)
    end)

    describe('registerComponentClass()', function()

    end)

    describe('componentClassExists()', function()
    
    end)

    describe('getComponentClass()', function()
    
    end)

    describe('registerSystemClass()', function()
    
    end)

    describe('systemClassExists()', function()
    
    end)

    describe('getSystemClass()', function()
    
    end)

    describe('registerDataClass()', function()
        
    end)

    describe('dataClassExists()', function()
    
    end)

    describe('getDataClass()', function()
    
    end)

    describe('mergeData()', function()
        it('copies string data to target', function()
            source = {foo='bar'}
            target = {}
            e:mergeData(source, target)
            assert.is.equal(target.foo, 'bar')
        end)
        it('copies boolean data to target', function()
            source = {foo=true}
            target = {}
            e:mergeData(source, target)
            assert.is.equal(target.foo, true)
        end)
        it('copies number data to target', function()
            source = {foo=2}
            target = {}
            e:mergeData(source, target)
            assert.is.equal(target.foo, 2)
        end)
        it('ignores metatable values', function()
            local source = {}
            local sourceMT = {foo='bar'}
            sourceMT.__index = sourceMT
            setmetatable(source, sourceMT)
            target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.foo)
        end)
        it('ignores keys that are functions', function()
            local k = function() end
            local source = {}
            source[k] = 'bar'
            target = {}
            e:mergeData(source, target)
            assert.is.Nil(target[k])
        end)
        it('ignores keys that are tables', function()
            local k = {}
            local source = {}
            source[k] = 'bar'
            target = {}
            e:mergeData(source, target)
            assert.is.Nil(target[k])
        end)
        it('ignores "class" keys', function()
            local source = {class='Test'}
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.class)
        end)
        it('ignores self references', function()
            local source = {}
            source.self = source
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.self)
        end)
        it('ignores function values', function()
            local source = {foo=function() end}
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.foo)
        end)
        it('does not copy __class entries to target', function()
            local source = {__class='Test'}
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.__class)
        end)
        it('ignores keys starting with "_"', function()
            local source = {_private='foo'}
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target._private)
        end)
        it('ignores references to classes', function()
            local source = {sceneClass=Scene}
            local target = {}
            e:mergeData(source, target)
            assert.is.Nil(target.sceneClass)
        end)
        it('copies table to target', function()
            local source = {foo={}}
            local target = {}
            e:mergeData(source, target)
            assert.is.True(type(target.foo) == 'table')
        end)
        it('target table entry is not the same as the source entry', function()
            local foo = {}
            local source = {foo=foo}
            local target = {}
            e:mergeData(source, target)
            assert.is_not.equal(source.foo, target.foo)
        end)
        it('recursively copies table data', function()
            local foo = {
                bar={
                    baz='bleh'
                }
            }
            local source = {foo=foo}
            local target = {}
            e:mergeData(source, target)
            assert.is.equal(target.foo.bar.baz, 'bleh')
        end)
    end)

    describe('importConfig()', function()
        it('merges data into engine config', function()
            local config = {updateStep=0.1}
            e:importConfig(config)
            assert.is.equal(e.config.updateStep, 0.1)
        end)
    end)
end)